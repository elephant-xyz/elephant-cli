import { UploadResult, ProcessedFile } from '../types/submit.types.js';
import { Semaphore } from 'async-mutex';
import { logger } from '../utils/logger.js';
import { RateLimiter } from '../utils/rate-limiter.js';
import path from 'path';
import { readdir, stat, readFile } from 'fs/promises';

export interface PinMetadata {
  name?: string;
  keyvalues?: Record<string, string | number | Date | null | undefined>;
}

export class PinataService {
  private pinataJwt: string;
  private semaphore: Semaphore;
  private rateLimiter: RateLimiter;
  private requestCount: number = 0;
  private lastCountReset: number = Date.now();

  private readonly pinataApiUrl =
    'https://api.pinata.cloud/pinning/pinFileToIPFS';
  private readonly PINATA_RATE_LIMIT = 300; // 300 requests per minute (conservative to avoid 429s)

  constructor(
    pinataJwt: string,
    _pinataSecretApiKey?: string,
    maxConcurrentUploads = 10
  ) {
    if (!pinataJwt) {
      throw new Error('Pinata JWT is required for authentication.');
    }
    this.pinataJwt = pinataJwt;
    this.semaphore = new Semaphore(maxConcurrentUploads);
    this.rateLimiter = new RateLimiter(this.PINATA_RATE_LIMIT);
    logger.info(
      `PinataService initialized with rate limit: ${this.PINATA_RATE_LIMIT} requests/minute`
    );
  }

  private async processUpload(
    fileToProcess: ProcessedFile & { binaryData?: Buffer; metadata?: any }
  ): Promise<UploadResult> {
    logger.debug(
      `Processing upload for ${fileToProcess.filePath} (CID: ${fileToProcess.calculatedCid})`
    );
    try {
      // Determine if this is a binary file (e.g., image)
      const isBinary = fileToProcess.binaryData !== undefined;
      const fileExtension =
        isBinary && fileToProcess.metadata?.isImage
          ? path.extname(fileToProcess.filePath)
          : '.json';

      const metadata: PinMetadata = {
        name: `${fileToProcess.dataGroupCid}${fileExtension}`,
        keyvalues: {
          propertyCid: fileToProcess.propertyCid,
          dataGroupCid: fileToProcess.dataGroupCid,
          originalCid: fileToProcess.calculatedCid,
        },
      };

      const fileBuffer = isBinary
        ? fileToProcess.binaryData!
        : Buffer.from(fileToProcess.canonicalJson);

      const mimeType = fileToProcess.metadata?.mimeType || 'application/json';

      return await this.uploadFileInternal(
        fileBuffer,
        metadata,
        fileToProcess,
        mimeType
      );
    } catch (error) {
      logger.error(
        `Error processing upload for ${fileToProcess.filePath}: ${error instanceof Error ? error.message : String(error)}`
      );
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        propertyCid: fileToProcess.propertyCid,
        dataGroupCid: fileToProcess.dataGroupCid,
      };
    }
  }

  /**
   * Internal method to upload a single file's content to Pinata v2 API (CID v0).
   * Includes retry logic.
   */
  private async uploadFileInternal(
    fileBuffer: Buffer,
    metadata: PinMetadata,
    originalFileInfo: ProcessedFile & { binaryData?: Buffer; metadata?: any },
    mimeType: string = 'application/json',
    retries: number = 10
  ): Promise<UploadResult> {
    let lastError: Error | undefined;

    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        logger.debug(`Attempt ${attempt + 1} to upload ${metadata.name}`);

        // Use native File and FormData (Node 18+)
        const file = new File([fileBuffer], metadata.name || 'file', {
          type: mimeType,
        });
        const form = new FormData();
        form.append('file', file);
        // Use CID v1 by default for all uploads
        form.append('pinataOptions', JSON.stringify({ cidVersion: 1 }));
        const pinataMetadata = JSON.stringify({
          name: metadata.name,
          keyvalues: metadata.keyvalues || {},
        });
        form.append('pinataMetadata', pinataMetadata);

        // Wait for rate limit before making the request
        await this.rateLimiter.waitForToken();

        // Track request count
        this.trackRequest();

        const response = await fetch(this.pinataApiUrl, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${this.pinataJwt}`,
            // Do NOT set Content-Type, let FormData handle it
          },
          body: form,
        });

        if (!response.ok) {
          const errorBody = await response.text();
          throw new Error(
            `Pinata API error: ${response.status} ${response.statusText} - ${errorBody}`
          );
        }

        const resultJson = await response.json();
        // v2 returns { IpfsHash: ... }
        const cid = resultJson?.IpfsHash;
        logger.info(
          `Successfully uploaded ${metadata.name} to IPFS. CID: ${cid}`
        );

        return {
          success: true,
          cid,
          propertyCid: originalFileInfo.propertyCid,
          dataGroupCid: originalFileInfo.dataGroupCid,
        };
      } catch (error) {
        lastError = error as Error;
        logger.debug(
          `Upload attempt ${attempt + 1} for ${metadata.name} failed: ${lastError.message}`
        );

        // Check if it's a 429 rate limit error
        const is429Error =
          lastError.message.includes('429') ||
          lastError.message.includes('RATE_LIMITED');

        if (attempt < retries) {
          let delay: number;

          if (is429Error) {
            // For 429 errors, use longer exponential backoff starting at 5s
            delay = Math.pow(2, attempt) * 5000; // 5s, 10s, 20s, 40s...
            logger.warn(
              `Rate limit hit (429). Backing off for ${delay / 1000}s before retry...`
            );

            // Also add some tokens back to the rate limiter to slow down overall
            const tokensToAdd = Math.min(50, attempt * 10);
            (this.rateLimiter as any).tokens = Math.min(
              (this.rateLimiter as any).tokens + tokensToAdd,
              (this.rateLimiter as any).maxTokens
            );
          } else {
            // For other errors, use normal exponential backoff
            delay = Math.pow(2, attempt) * 1000; // 1s, 2s, 4s, 8s...
            logger.debug(`Retrying upload in ${delay / 1000}s...`);
          }

          await new Promise((resolve) => setTimeout(resolve, delay));
        }
      }
    }

    logger.debug(
      `Failed to upload ${metadata.name} after ${retries + 1} attempts.`
    );
    return {
      success: false,
      error: lastError?.message || 'Unknown upload error',
      propertyCid: originalFileInfo.propertyCid,
      dataGroupCid: originalFileInfo.dataGroupCid,
    };
  }

  // Public facing uploadFile - for direct use with Buffer
  public async uploadFile(
    data: Buffer,
    metadata: PinMetadata
  ): Promise<UploadResult> {
    const dummyFileInfo: ProcessedFile = {
      propertyCid:
        (metadata.keyvalues?.propertyCid as string) || 'unknownProperty',
      dataGroupCid:
        (metadata.keyvalues?.dataGroupCid as string) || 'unknownGroup',
      filePath: metadata.name || 'unknownFile.json',
      canonicalJson: '',
      calculatedCid: '',
      validationPassed: true,
    };
    return this.uploadFileInternal(data, metadata, dummyFileInfo);
  }

  public async uploadBatch(
    files: (ProcessedFile & { binaryData?: Buffer; metadata?: any })[]
  ): Promise<UploadResult[]> {
    if (files.length === 0) {
      return [];
    }

    // Use semaphore to limit concurrent uploads
    const uploadPromises = files.map(async (file) => {
      return await this.semaphore.runExclusive(async () => {
        logger.debug(`Uploading ${file.filePath} to IPFS.`);
        return await this.processUpload(file);
      });
    });

    // Wait for all uploads to complete
    return await Promise.all(uploadPromises);
  }

  // No longer needed: getAuthHeaders (JWT only, handled inline)

  /**
   * Track request count and log statistics
   */
  private trackRequest(): void {
    this.requestCount++;

    // Reset counter every minute and log stats
    const now = Date.now();
    const elapsed = now - this.lastCountReset;

    if (elapsed >= 60000) {
      // 1 minute
      logger.info(
        `Pinata request stats: ${this.requestCount} requests in the last ${(elapsed / 1000).toFixed(1)}s ` +
          `(${(this.requestCount / (elapsed / 60000)).toFixed(1)} req/min)`
      );
      this.requestCount = 0;
      this.lastCountReset = now;
    } else if (this.requestCount % 50 === 0) {
      // Log every 50 requests
      logger.info(
        `Pinata requests: ${this.requestCount} in ${(elapsed / 1000).toFixed(1)}s ` +
          `(current rate: ${(this.requestCount / (elapsed / 60000)).toFixed(1)} req/min)`
      );
    }
  }

  /**
   * Recursively get all files in a directory
   * @param dir - Directory path
   * @returns Array of file paths
   */
  private async getAllFiles(dir: string): Promise<string[]> {
    const files: string[] = [];

    async function walk(currentPath: string) {
      const entries = await readdir(currentPath, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(currentPath, entry.name);

        if (entry.isDirectory()) {
          await walk(fullPath);
        } else if (entry.isFile()) {
          files.push(fullPath);
        }
      }
    }

    await walk(dir);
    return files;
  }

  /**
   * Get relative path from base directory
   * @param base - Base directory path
   * @param file - File path
   * @returns Relative path with only parent directory and filename
   */
  private getRelativePath(base: string, file: string): string {
    const relativePath = path.relative(base, file);
    const parsed = path.parse(relativePath);

    // If file is in a subdirectory, use its immediate parent directory
    if (parsed.dir) {
      const parentDir = path.basename(parsed.dir);
      return path.posix.join(parentDir, parsed.base);
    }

    // If file is directly in the base directory, use the base directory name
    const baseDirName = path.basename(base);
    return path.posix.join(baseDirName, parsed.base);
  } /**
   * Upload an entire directory to Pinata, preserving the directory structure.
   * @param directoryPath - The absolute path to the directory to upload
   * @param metadata - Optional metadata for the upload
   * @returns UploadResult with the CID of the uploaded directory
   */
  public async uploadDirectory(
    directoryPath: string,
    metadata?: PinMetadata
  ): Promise<UploadResult> {
    try {
      logger.debug(`Starting directory upload for: ${directoryPath}`);

      // Check if directory exists
      const dirStats = await stat(directoryPath).catch(() => null);
      if (!dirStats || !dirStats.isDirectory()) {
        throw new Error(`Directory not found: ${directoryPath}`);
      }

      // Read all files in the directory recursively
      const files = await this.getAllFiles(directoryPath);

      if (files.length === 0) {
        throw new Error(`No files found in directory: ${directoryPath}`);
      }

      logger.debug(`Found ${files.length} files to upload`);

      // Create form data using native FormData
      const form = new FormData();

      // Add each file to the form data with its relative path
      for (const filePath of files) {
        const relativePath = this.getRelativePath(directoryPath, filePath);
        const fileContent = await readFile(filePath);

        // Create a File object with the relative path
        const file = new File([fileContent], relativePath, {
          type: 'application/octet-stream',
        });

        logger.info(`relativePath is ${relativePath}`);
        // Append with the filepath parameter to preserve directory structure
        form.append('file', file, relativePath);
      }

      // Use CID v1 by default for all uploads
      form.append('pinataOptions', JSON.stringify({ cidVersion: 1 }));
      if (metadata) {
        const pinataMetadata = JSON.stringify({
          name: metadata.name || path.basename(directoryPath),
          keyvalues: metadata.keyvalues || {},
        });
        form.append('pinataMetadata', pinataMetadata);
      }

      // Wait for rate limit before making the request
      await this.rateLimiter.waitForToken();

      // Track request count
      this.trackRequest();

      // Make the request using fetch with native FormData
      const response = await fetch(this.pinataApiUrl, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.pinataJwt}`,
          // Let fetch set the Content-Type with boundary
        },
        body: form,
      });

      if (!response.ok) {
        const errorBody = await response.text();
        throw new Error(
          `Pinata API error: ${response.status} ${response.statusText} - ${errorBody}`
        );
      }

      const resultJson = await response.json();
      const cid = resultJson?.IpfsHash;

      logger.info(
        `Successfully uploaded directory ${directoryPath} to IPFS. CID: ${cid}`
      );

      return {
        success: true,
        cid,
        propertyCid:
          (metadata?.keyvalues?.propertyCid as string) || directoryPath,
        dataGroupCid:
          (metadata?.keyvalues?.dataGroupCid as string) || 'directory',
      };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      logger.error(`Failed to upload directory ${directoryPath}: ${errorMsg}`);

      return {
        success: false,
        error: errorMsg,
        propertyCid:
          (metadata?.keyvalues?.propertyCid as string) || directoryPath,
        dataGroupCid:
          (metadata?.keyvalues?.dataGroupCid as string) || 'directory',
      };
    }
  }
}
